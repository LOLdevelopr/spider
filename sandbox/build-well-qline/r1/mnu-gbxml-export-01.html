<!doctype html>
<html lang = "en" >
<head>
<meta charset = "utf-8" >
<meta name = "viewport" content= "width=device-width, initial-scale=1">
<meta name = "description" content = "Save Build Well as a gbXML file" >
<meta name = "keywords" content = "Three.js,WebGL,JavaScript,GitHub,FOSS,3D,STEM" >
<meta name = "date" content = "2017-10-18" >
<title>gbXML Export</title>
<style>
/* Copyright 2018 Ladybug Tools authors. MIT License */

/* https://www.w3schools.com/colors/colors_names.asp */

	html { --mnu-color: blue; --mnu-back-color: lavender; --mnu-width: 300px;  height: 100%; }

	body { font: 12pt monospace;  height: 100%; margin: 0 auto; overflow: hidden; }
	a { color: var( --mnu-color ); text-decoration: none; }
	a:hover, a:focus{ background-color: yellow; color: #aaa; }

	button, input[type=button] { background-color: #ddd; border: none; color: var( --mnu-color ); cursor: pointer;padding: 3px 20px; }
	button:hover { background-color: #ccc; color: #fff }

	h3 { margin: 0; }

	input[type=range] { -webkit-appearance: none; -moz-appearance: none; background-color: #ddd; width: 100%; }
	input[type=range]::-moz-range-thumb { background-color: #888; border-radius: 0; width: 10px; }
	input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; background-color: #888; height: 20px; width: 10px; }

	select { width: 100%; }

	.floatRight { float: right; width: 70px;}
	.highlight { background-color: lightgreen; }

	#divMenu { background-color: var( --mnu-back-color ); border: 1px solid var( --mnu-color ); padding: 5px;  }

	#ifrContents { box-sizing: border-box; border: 0px solid var( --mnu-color ); height: 100%; width: 100%; }

</style>
</head>
<body>

	<div id = "divMenu" >

		<div id = "divTitle" ></div>

		<p id = "divInfo" ></p>

		<p title = 'Select a building to edit' >Buildings:
			<select id = selObject onchange = getObject(buildings); size = 9 ></select>
		</p>

		<p> 1. <button onclick=getBuildingData(); >Get building data</button></p>

		<p> 2. <button onclick = saveFile(); >Save building data to file</button> </p>

		<p> 1. First the click the 'get building data' button. The data will display on-screen so you can check if it is OK.</p>

		<p> 2. If the data is acceptable, you may save the data to a file.</p>

		<p> Along with the data, little boxes appear at vertices. These are to help you identify that the script is identifying coordinates correctly.</p>

		<p> View the <a href="https://en.wikipedia.org/wiki/Green_Building_XML" target="_blank">gbXML</a> file
			using <a href="http://www.ladybug.tools/spider/read-gbxml/gbxml-viewer/" target="_blank">Spider gbXML Viewer</a></p>

	</div>

	<iframe id=ifrContents ></iframe>

<script>

	let bwId;
	let idSpacesStart;

	let textMenu;
	let textZones;

	let building;
	let buildings;
	let zones;
	let storeys;
	let spaces;

	const ifrSource = 'build-well-threejs-qline.html';

	const pathArry  = location.pathname.split( '/' ).slice( -2);
	const release = pathArry[ 0 ]
	const fileName = pathArry[ 1 ];
	const infoURI = 'https://github.com/ladybug-tools/spider/tree/master/sandbox/build-well-qline/' + release + '/' + fileName;

	let scope;
	let v = function( x, y, z ){ return new THREE.Vector3( x, y, z ); };
	const d2r = Math.PI / 180, r2d = 180 / Math.PI;

	var THREE;
	var renderer;
	var camera;
	var controls;
	var scene;

	var lightAmbient, lightPoint, lightDirectional;
	var axisHelper, cameraHelper;

	let geometry, material, mesh;


	init();


	function init() {

		divTitle.innerHTML =
			'<h3>' +
				( window.self === window.top ? '<a href="./build-well.html" target="_top">bwell</a><br>' : '' ) +
				'<a  href = "" >' + document.title + ' ' + release.toUpperCase() + '</a> &nbsp; ' +
				'<a href=' + infoURI + ' target="_top" > <img src="https://pushme-pullyou.github.io/github-mark-64.png" height=18 > </a>' +
			'</h3>' +
		'';

		let txt = 'lorem ipsum, quia dolor sit, amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt, ut labore et dolore magnam aliquam quaerat voluptatem. ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur? quis autem vel eum iure reprehenderit, qui in ea voluptate velit esse, quam nihil molestiae consequatur, vel illum, qui dolorem eum fugiat, quo voluptas nulla pariatur?';

		if ( parent && parent.ifrThree ) {

			scope = parent.ifrThree.contentWindow;

			initVariables();


		} else {

			ifrContents.src = ifrSource;

			scope = ifrContents.contentWindow;

			divMenu.style.cssText += ' margin: 20px;max-height: calc( 100% - 50px);  max-width: 300px; ; overflow: auto; position: absolute; right: 0;' ;

			ifrContents.onload = initVariables;

		}

	}



	function initVariables() {

		THREE = scope.THREE;
		renderer = scope.renderer;
		scene = scope.scene;
		camera = scope.camera;
		controls = scope.controls;

		lightDirectional = scope.lightDirectional;
		axesHelper = scope.axesHelper;
		gridHelper = scope.gridHelper;
		groundHelper = scope.groundHelper;
		cameraHelper = scope.cameraHelper;

		building = scope.building;
		buildings = scope.buildings;

//console.log( 'building', buildings );

		updateSelectObjects( buildings );

	}



	function updateSelectObjects( objects ) {

		selObject.innerHTML = '';

		for ( let i = 0; i < objects.children.length; i++ ) {

			let obj = objects.children[ i ];
			selObject.innerHTML += '<option>' + obj.name + '</option>';

		}

		selObject.selectedIndex = 0;

		getObject( objects );

	}



	function getObject( objects ) {
//
		const object = objects.getObjectByName( selObject.value );

//console.log( 'object', object );

		objects.traverse( function ( child ) {

			if ( child instanceof THREE.Mesh ) {

					child.material.opacity = child.name === object.name ? 1 : 0.25;

			}

		} );

		building.mesh = object;

	}



	function getBuildingData() {

//console.log( 'buildings', buildings );
//console.log( 'building', building );

		textMenu = '';

		textMenu +=
//			'<?xml version="1.0" encoding="UTF-16"?>\n' +
			'<?xml version="1.0" encoding="UTF-8"?>\n' +
//			'<gbXML useSIUnitsForResults="true" temperatureUnit="C" lengthUnit="Meters" areaUnit="SquareMeters" volumeUnit="CubicMeters" version="0.37" xmlns="http://www.gbxml.org/schema">\n' +
			'<gbXML xmlns="http://www.gbxml.org/schema" xmlns:xsd="http://www.w3.org/2001/XMLSchema" ' +
				'xsi:schemaLocation="http://www.gbxml.org/schema http://gbxml.org/schema/6-01/GreenBuildingXML_Ver6.01.xsd" ' +
				'xmlns:xhtml="http://www.w3.org/1999/xhtml" ' +
				'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" ' +
				'useSIUnitsForResults="' + building.useSIUnitsForResults + '" ' +
				'SurfaceReferenceLocation="' + building.SurfaceReferenceLocation + '" ' +
				'temperatureUnit="' + building.temperatureUnit + '" ' +
				'lengthUnit="' + building.lengthUnit + '" ' +
				'areaUnit="' + building.areaUnit + '" ' +
				'volumeUnit="' + building.volumeUnit + '" ' +
				'version="' + building.version + '" >\n' +

			'\t<Campus id="' + building.campusId + '" >\n' +

			'\t\t<DaylightSavings>"' + building.DaylightSavings + '"</DaylightSavings>\n' +
			'\t\t<Name>"' + building.mesh.name + '"</Name>\n' +
			'\t\t<Location>\n' +
			'\t\t\t<ZipcodeOrPostalCode>"' + building.ZipcodeOrPostalCode + '"</ZipcodeOrPostalCode>\n' +
			'\t\t\t<Longitude>"' + building.Longitude + '"</Longitude>\n' +
			'\t\t\t<Latitude>"' + building.Latitude + '"</Latitude>\n' +
			'\t\t\t<Elevation>"' + building.Elevation + '"</Elevation>\n' +
			'\t\t\t<CADModelAzimuth>"' + building.CADModelAzimuth + '"</CADModelAzimuth>\n' +
			'\t\t\t<Name>"' + building.mesh.name + '"</Name>\n' +
			'\t\t</Location>\n' +
			'\t\t<Building id="bw-building-' + building.buildingId + '" buildingType="Office" >\n' +
			'\t\t\t<Area>' + building.area + '</Area>\n' +
			'\t\t\t<Name>"' + building.mesh.name + '"</Name>\n' +
			'\t\t\t<Description>' + building.description + '</Description>\n' +
			'\t\t\t<StreetAddress>"' + building.streetAddress + '"</StreetAddress>\n' +
			'\t\t\t<Volume>' + building.volume + '</Volume>\n' +
		'';


		textMenu += getBuildingStoreys( building );

		textMenu += getSpaces( building );

		textMenu += '\t\t</Building>\n';

		textMenu += getSurfaces( buildings );

		zonesText = getZones( building );

		textMenu +=

			'\t</Campus>\n' +
			zonesText +
			'\t<DocumentHistory>\n' +
			'\t</DocumentHistory>\n' +
			'</gbXML>\n' +
		'';



		if ( parent && parent.ifrThree ) {

			parent.divContents.innerHTML =

				'gbXML data<textarea id=buildingData >' +
				textMenu + '</textarea>'

			'';

			parent.divContents.style.cssText = 'border: 0px solid red; left: 325px; margin: 0 auto; max-width: 800px; right: 0;';
			parent.divContents.style.display = '';
			parent.viewContents();

		} else {

		scope.divScreenText.innerHTML =

			'gbXML data<textarea id=buildingData >' +
			textMenu + '</textarea>'

		'';

		}

	}




	function getBuildingStoreys( building ) {

		let textBuildingStoreys = '';

		for ( var i = 0; i < building.floors; i++ ) {

			textBuildingStoreys +=
				'\t\t\t<BuildingStorey id="bw-storey-' + ( i + 1 ) + '" >\n' +
				'\t\t\t\t<Name>"storey-' + ( i + 1 ) + '"</Name>\n' +
				'\t\t\t\t<Level>' + ( i * building.floorHeight + 1 ) + '</Level>\n' +
				'\t\t\t</BuildingStorey>\n' +
			'';

		}

//console.log( 'textBuildingStoreys', textBuildingStoreys );

		return textBuildingStoreys;

	}



	function getSpaces( building ) {
//console.log( '', building );
		let textSpace = '';

		const vertices = building.mesh.children[ 0 ].geometry.vertices;
		const spacesCount = vertices.length / 5 - 1;
		const spaces = building.spaces;

storey = 1;

		for ( var i = 0; i < spacesCount; i++ ) {

// needs checking
			const vertex1 = vertices[ i * 5 ];
			const vertex2 = vertices[ ( i + 1 ) * 5 ];
			const area = vertex1.distanceTo( vertex2 ) * building.perimeterDepth;
			const volume = area * building.floorHeight;

			spaces.push( { name: 'space ' + ( i + 1 ), id: ( i + 1 ), description: 'a space',
				area: area, storey: storey, volume: volume, zone: ( i + 1 ) } );

		}

		for ( var i = 0; i < spaces.length; i++ ) {

			const space = spaces[ i ];

			textSpace +=
				'\t\t\t<Space zoneIdRef="bw-zone-' + space.zone + '" ' +
					'id="bw-space-' + ( i + 1 ) + '" ' +
					'buildingStoreyIdRef="bw-storey-' + space.storey + '" ' +
					'conditionType="HeatedAndCooled" >\n' +
				'\t\t\t\t<Name>' + space.name + '</Name>\n' +
				'\t\t\t\t<Description>' + space.description + '</Description>\n' +
				'\t\t\t\t<Area>' + space.area + '</Area>\n' +
				'\t\t\t\t<Volume>' + space.volume + '</Volume>\n' +
				'\t\t\t</Space>\n' +

			'';

		}

//console.log( 'spaces', spaces );

		return textSpace;

	}


	function getZones( building ) {

		let textZones = '';


		const vertices = building.mesh.children[ 0 ].geometry.vertices;
		const zonesCount = vertices.length / 5 - 1;
		const zones = building.zones;

		for ( var i = 0; i < zonesCount; i++ ) {

				building.zones.push( { name: 'zone ' + ( i + 1 ), description: 'a zone' } );

		}


		for ( let i = 0; i < building.zones.length; i++ ) {

			const zone = building.zones[ i ];
			textZones +=
				'\t<Zone id="bw-zone-' + ( i + 1 ) + '" >\n' +
				'\t\t<Name>' + zone.name + '</Name>\n' +
				'\t\t<Description>' + zone.description + '</Description>\n' +
				'\t</Zone>\n' +
			'';

		}


//console.log( 'textZones', textZones );

		return textZones;

	}



	function getSurfaces( buildings ) {

		let textSurfaces = '';

		for ( let i = 0; i < buildings.children.length; i++ ) {

			aBuilding = buildings.children[ i ];

			if ( aBuilding.name !== selObject.value ) {
//console.log( '', aBuilding );

				textSurfaces += getSurfacesAdjacentBuildings( aBuilding );

			} else {
//console.log( 'building', building );

				textSurfaces += getSurfacesTheBuilding( aBuilding );

			}

		}

//		textSurfaces += getSurfacesOverhangs( building );

		return textSurfaces;

	}



	function getSurfacesTheBuilding( building ) {

console.log( 'building', building.children[ 0 ] );
		const geo = new THREE.BoxBufferGeometry( 3, 1, 10 );
		const material = new THREE.MeshNormalMaterial( { opacity: 0.85, transparent: true } );

		let v1, v2, v3, v4; // note v2 is used elsewhere!!!

		let textSurfacesBits = '';

		for ( let i = 0; i < building.children.length; i++ ) {

			const meshFloor = building.children[ i ];
			const vertices = meshFloor.geometry.vertices;
			const spacesCount = vertices.length / 5 - 1;
			const path = [];

			for ( var j = 0; j < spacesCount; j++ ) {

				const pt1 = j * 5 ;
				pt2 = pt1 + 5;

				let quad = [ vertices[ pt1 ], vertices[ pt1 + 1 ], vertices[ pt2 + 1 ], vertices[ pt2 ] ];
				textSurfacesBits += getSingleSurface( meshFloor, quad, 'ExteriorWall' , i );

				quad = [ vertices[ pt1 + 1 ], vertices[ pt1 + 2 ], vertices[ pt2 + 2 ], vertices[ pt2 + 1 ] ];
				textSurfacesBits += getSingleSurface( meshFloor, quad, 'InteriorFloor' , i );

				quad = [ vertices[ pt1 + 2 ], vertices[ pt1 + 3 ], vertices[ pt2 + 3 ], vertices[ pt2 + 2 ] ];
				textSurfacesBits += getSingleSurface( meshFloor, quad, 'InteriorWall' , i );

				quad = [ vertices[ pt1 + 3 ], vertices[ pt1 + 4 ], vertices[ pt2 + 4 ], vertices[ pt2 + 3 ] ];
				textSurfacesBits += getSingleSurface( meshFloor, quad, 'Ceiling' , i );

				path.push( vertices[ pt1 + 2 ] );

			}

			textSurfacesBits += getSurfacesSlabs( meshFloor, path );

		}

		return textSurfacesBits;

	}


	function getSingleSurfacecccccccccccc( building, vertices, type, id ) {

		const geo = new THREE.BoxBufferGeometry( 3, 1, 10 );
		const material = new THREE.MeshNormalMaterial( { opacity: 0.85, transparent: true } );

		let textSingleSurfaces =

			'\t\t<Surface surfaceType="' + type + '" id="bw-surface-' + id + '" >\n' +
//				'\t\t\t<Name>' + surface.name + '</Name>\n' +
			'\t\t\t<CADOjectId>none</CADOjectId>\n' +
			'\t\t\t<AdjacentSpaceId spaceIdRef="bw-space-' + id  + '" />\n' +
			'\t\t\t<PlanarGeometry>\n' +
			'\t\t\t\t<PolyLoop>\n' +
		'';

		const v1 = building.children[ 0 ].localToWorld ( vertices[ 0 ].clone() );
		const v2 = building.children[ 0 ].localToWorld ( vertices[ 1 ].clone() );
		const v3 = building.children[ 0 ].localToWorld ( vertices[ 2 ].clone() );
		const v4 = building.children[ 0 ].localToWorld ( vertices[ 3 ].clone() );

		const quad = [ v1, v2, v3, v4 ];

		for ( k = 0; k < 4; k++ ) {

			vertex = quad[ k ];

			textSingleSurfaces += getCartesianPointText( vertex );

			mesh = new THREE.Mesh( geo, material );
			mesh.position.add( vertex );
			scene.add( mesh );

		}

		textSingleSurfaces +=
			'\t\t\t\t</PolyLoop>\n' +
			'\t\t\t\t</PlanarGeometry>\n' +
				( type === 'ExteriorWall' ? getOpening( building, vertices, id ) : '' ) +
//				'\t\t\t</Opening>\n' +
			'\t\t</Surface>\n' +
		'';

		return textSingleSurfaces

	}


	function getSingleSurface( floor, vertices, type, id ) {

		const geo = new THREE.BoxBufferGeometry( 3, 1, 10 );
		const material = new THREE.MeshNormalMaterial( { opacity: 0.85, transparent: true } );

		let textSingleSurfaces =

			'\t\t<Surface surfaceType="' + type + '" id="bw-surface-' + id + '" >\n' +
//				'\t\t\t<Name>' + surface.name + '</Name>\n' +
			'\t\t\t<CADOjectId>none</CADOjectId>\n' +
			'\t\t\t<AdjacentSpaceId spaceIdRef="bw-space-' + id  + '" />\n' +
			'\t\t\t<PlanarGeometry>\n' +
			'\t\t\t\t<PolyLoop>\n' +
		'';

		for ( let i = 0; i < vertices.length; i++ ) {

			vertex = floor.localToWorld ( vertices[ i ].clone() );

			textSingleSurfaces += getCartesianPointText( vertex );

			mesh = new THREE.Mesh( geo, material );
			mesh.position.add( vertex );
			scene.add( mesh );

		}

		textSingleSurfaces +=
			'\t\t\t\t</PolyLoop>\n' +
			'\t\t\t\t</PlanarGeometry>\n' +
				( type === 'ExteriorWall' ? getOpening( building, vertices, id ) : '' ) +
//				'\t\t\t</Opening>\n' +
			'\t\t</Surface>\n' +
		'';

		return textSingleSurfaces

	}


	function getOpening( building, vertices, id ) {

console.log( 'opening', 23 );

		let textOpening =
//			'\t\t\t\t</PolyLoop>\n' +
//			'\t\t\t</PlanarGeometry>\n' +
			'\t\t\t<Opening openingType="OperableWindow" id="bw-opening-' + id + '" >\n' +
			'\t\t\t\t<PlanarGeometry>\n' +
			'\t\t\t\t\t<PolyLoop>\n' +
		'';



		textOpening +=
			'\t\t\t\t</PolyLoop>\n' +
			'\t\t\t\t</PlanarGeometry>\n' +
			'\t\t\t</Opening>\n' +
//			'\t\t</Surface>\n' +
		'';

		return ''; //textOpening;

	}


	function getSurfacesSlabs( floor, path ) {

console.log( 'path', path );

		textInterior = '';

		shape = new THREE.Shape( path );
		geometry = new THREE.ShapeGeometry( shape );

		textInterior += getSingleSurface( floor, geometry.vertices, 'InteriorFloor', 23 )

		material = new THREE.MeshNormalMaterial();
		mesh = new THREE.Mesh( geometry, material );
		mesh.position.copy( floor.position );
		scene.add( mesh );


		return textInterior;

	}


	function getSurfacesSlabsXXX( building ) {

		let textSlabs = '';

		const geometry = new THREE.BoxBufferGeometry( 3, 1, 1 );
		const material = new THREE.MeshNormalMaterial( { opacity: 0.85, transparent: true } );

		for ( var i = 0; i < building.slabs.length; i++ ) {

			const slab = building.slabs[ i ];

			textSlabs +=
				'\t\t<Surface surfaceType="' + slab.name + '" id="bw-' + slab.name + '-building-' + ( i + 1 ) + '" >\n' +
				'\t\t\t<Name>' + building.mesh.name +'</Name>\n' +
				'\t\t\t<PlanarGeometry>\n' +
				'\t\t\t\t<PolyLoop>\n' +
			'';

			const coordinates = slab.geometry.attributes.position.array;

			const vertices = [

				v( coordinates[ 6 ], coordinates[ 7 ], coordinates[ 8 ] ),
				v( coordinates[ 9 ], coordinates[ 10 ], coordinates[ 11 ] ),
				v( coordinates[ 3 ], coordinates[ 4 ], coordinates[ 5 ] ),
				v( coordinates[ 0 ], coordinates[ 1 ], coordinates[ 2 ] ),

			];

			for ( let j = 0; j < 4; j++ ) {

				vertex = vertices[ j ];
				vertex.applyMatrix4( slab.matrixWorld );
				textSlabs += getCartesianPointText( vertex );


				const mesh = new THREE.Mesh( geometry, material );
				mesh.position.copy( vertex );
				mesh.name = 'shade';
				scene.add( mesh );
//console.log( 'vertex', mesh.position );

			}

			textSlabs +=
				'\t\t\t\t</PolyLoop>\n' +
				'\t\t\t</PlanarGeometry>\n' +
				'\t\t</Surface>\n' +
			'';
		}

//console.log( 'textSlabs', textSlabs );

		return textSlabs;

	}



	function getSurfacesOverhangs( building ) {

		let textOver = '';
		const geometry = new THREE.BoxBufferGeometry( 3, 2, 1 );
		const material = new THREE.MeshNormalMaterial( { opacity: 0.85, transparent: true } );

		for ( var i = 0; i < building.overhangs.length; i++ ) {

			const overhang = building.overhangs[ i ];

			textOver +=
				'\t\t<Surface surfaceType="Shade" id="bw-shade-building-' + ( i + 1 ) + '" >\n' +
				'\t\t\t<Name>' + building.mesh.name +'</Name>\n' +
				'\t\t\t<PlanarGeometry>\n' +
				'\t\t\t\t<PolyLoop>\n' +
			'';

//console.log( 'geo', overhang.geometry.attributes.position.array );

			const coordinates = overhang.geometry.attributes.position.array;

			const vertices = [

				v( coordinates[ 6 ], coordinates[ 7 ], coordinates[ 8 ] ),
				v( coordinates[ 9 ], coordinates[ 10 ], coordinates[ 11 ] ),
				v( coordinates[ 3 ], coordinates[ 4 ], coordinates[ 5 ] ),
				v( coordinates[ 0 ], coordinates[ 1 ], coordinates[ 2 ] ),

			];

			for ( let j = 0; j < 4; j++ ) {

				vertex = vertices[ j ];
				vertex.applyMatrix4( overhang.matrixWorld );
				textOver += getCartesianPointText( vertex );

/*
				const mesh = new THREE.Mesh( geometry, material );
				mesh.position.copy( vertex );
				mesh.name = 'shade';
				scene.add( mesh );
//console.log( 'vertex', mesh.position );
*/

			}

			textOver +=
				'\t\t\t\t</PolyLoop>\n' +
				'\t\t\t</PlanarGeometry>\n' +
				'\t\t</Surface>\n' +
			'';
		}

//console.log( 'textOver', textOver );

		return textOver;

	}





	function getSurfacesAdjacentBuildings( building ) {

		let textMenu = '';

//console.log( '', building );

//		const geo = building.geometry;
//		geo.computeBoundingBox();
		const bb = new THREE.Box3().setFromObject( building );

//		const bb  = geo.boundingBox;
		const mi = bb.min;
		const mx = bb.max;

		const geometry = new THREE.BoxBufferGeometry( 1, 1, 100 );
		const material = new THREE.MeshNormalMaterial( { opacity: 0.85, transparent: true } );

		const faces =  [
			[v( mi.x, mi.y, mi.z ), v( mx.x, mi.y, mi.z ), v( mx.x, mi.y, mx.z ), v( mi.x, mi.y, mx.z ) ],
			[v( mi.x, mx.y, mi.z ), v( mx.x, mx.y, mi.z ), v( mx.x, mx.y, mx.z ), v( mi.x, mx.y, mx.z ) ],
			[v( mi.x, mi.y, mi.z ), v( mi.x, mx.y, mi.z ), v( mi.x, mx.y, mx.z ), v( mi.x, mi.y, mx.z ) ],
			[v( mx.x, mi.y, mi.z ), v( mx.x, mx.y, mi.z ), v( mx.x, mx.y, mx.z ), v( mx.x, mi.y, mx.z ) ],
			[v( mi.x, mi.y, mx.z ), v( mx.x, mi.y, mx.z ), v( mx.x, mx.y, mx.z ), v( mi.x, mx.y, mx.z ) ]
		]

		for ( let i = 0; i < faces.length; i++ ) {

			textMenu +=
				'\t\t<Surface surfaceType="Shade" id="bw-shade-' + ( i + 1 ) + '" >\n' +
				'\t\t\t<Name>' + building.name +'</Name>\n' +
				'\t\t\t<PlanarGeometry>\n' +
				'\t\t\t\t<PolyLoop>\n' +
			'';

			face = faces[ i ];
			const v1 = building.localToWorld ( face[ 0 ] );
			const v2 = building.localToWorld ( face[ 1 ] );
			const v3 = building.localToWorld ( face[ 2 ] );
			const v4 = building.localToWorld ( face[ 3 ] );

//			const vertices = [ v2, v1, v3, v4 ];
			const vertices = [ v1, v2, v3, v4 ];
			for ( let k = 0; k < 4; k++ ) {

				const vertex = vertices[ k ];
				textMenu += getCartesianPointText( vertex );

				const mesh = new THREE.Mesh( geometry, material );
				mesh.position.copy( vertex );
				scene.add( mesh );

			}

			textMenu +=
				'\t\t\t\t</PolyLoop>\n' +
				'\t\t\t</PlanarGeometry>\n' +
				'\t\t</Surface>\n' +
			'';

		}

		return textMenu;

	}



	function getCartesianPointText( vertex ) {

		const textMenu =

			'\t\t\t\t\t<CartesianPoint>\n' +

				'\t\t\t\t\t\t<Coordinate>' + Number( vertex.x.toFixed(4) ) + '</Coordinate>\n' +
				'\t\t\t\t\t\t<Coordinate>' + Number( vertex.y.toFixed(4) ) + '</Coordinate>\n' +
				'\t\t\t\t\t\t<Coordinate>' + Number( vertex.z.toFixed(4) ) + '</Coordinate>\n' +

			'\t\t\t\t\t</CartesianPoint>\n' +

		'';

		return textMenu;

	}



	function saveFile() {

		let blob;
		if ( parent && parent.ifrThree ) {
			blob = new Blob( [ parent.buildingData.value ] );
console.log( 'parent.buildingData', parent.buildingData.value );

		} else {

			blob = new Blob( [ scope.buildingData.value ] );

		}

		var a = document.body.appendChild( document.createElement( 'a' ) );
		a.href = window.URL.createObjectURL( blob );
		a.download = 'building-data.xml';
		a.click();
//		delete a;
		a = null;

	}

</script>
</body>
</html>